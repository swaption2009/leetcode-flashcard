[
  {
    "id": 1,
    "level": "Easy",
    "question": {
      "title": "1. Two Sum",
      "description": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
      "examples": "Example 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]"
    },
    "answer": {
      "algorithm": "We can use a hash map to solve this problem in one pass. We will iterate through the array, and for each element, we check if its complement (target - current element) is already in the hash map. If it is, we have found our pair. If not, we add the current element and its index to the hash map.",
      "bigO": "Time: O(n), Space: O(n)",
      "code": "class Solution(object):\n    def twoSum(self, nums, target):\n        hash_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in hash_map:\n                return [hash_map[complement], i]\n            hash_map[num] = i"
    }
  },
  {
    "id": 2,
    "level": "Medium",
    "question": {
      "title": "2. Add Two Numbers",
      "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
      "examples": "Example 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]"
    },
    "answer": {
      "algorithm": "We can iterate through both linked lists simultaneously, adding the corresponding digits along with a carry from the previous step. We'll create a new linked list to store the result. The iteration continues until both lists are traversed and there's no carry left.",
      "bigO": "Time: O(max(m, n)), Space: O(max(m, n))",
      "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n        while l1 is not None or l2 is not None or carry != 0:\n            l1_val = l1.val if l1 else 0\n            l2_val = l2.val if l2 else 0\n            total = l1_val + l2_val + carry\n            current.next = ListNode(total % 10)\n            carry = total // 10\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n            current = current.next\n        return dummy_head.next"
    }
  },
  {
    "id": 3,
    "level": "Hard",
    "question": {
      "title": "42. Trapping Rain Water",
      "description": "Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
      "examples": "Example 1:\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\nExample 2:\nInput: height = [4,2,0,3,2,5]\nOutput: 9"
    },
    "answer": {
      "algorithm": "We can solve this using two pointers, one at the beginning and one at the end of the array. We also keep track of the maximum height seen so far from the left (`left_max`) and from the right (`right_max`). At each step, we move the pointer with the smaller `max_height`. The water trapped at the current position is the difference between the `max_height` on its side and its own height.",
      "bigO": "Time: O(n), Space: O(1)",
      "code": "class Solution(object):\n    def trap(self, height):\n        if not height:\n            return 0\n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        water = 0\n        while left < right:\n            if left_max < right_max:\n                left += 1\n                left_max = max(left_max, height[left])\n                water += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                water += right_max - height[right]\n        return water"
    }
  }
] 